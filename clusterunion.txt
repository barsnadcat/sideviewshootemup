





FParticleDynamics::SetAcceleration
FPhysicsSolverBase::AddDirtyProxy
Chaos::TPBDRigidParticle<double,3>::AddForce(const Chaos::TVector<double,3> & InF, bool bInvalidate) Line 3419	C++
Chaos::TThreadedSingleParticlePhysicsProxyBase<1>::AddForce(const Chaos::TVector<double,3> & InForce, bool bInvalidate) Line 590	C++
FChaosStateOps<Chaos::FRigidBodyHandle_External>::AddForceAtPosition(Chaos::FRigidBodyHandle_External & BodyHandle, const UE::Math::TVector<double> & Force, const UE::Math::TVector<double> & Position, bool bAllowSubstepping, bool bIsLocalForce) Line 906	C++
	
FBodyInstance::AddForceAtPosition::__l2::<lambda_1>::operator()() Line 3433	C++
FBodyInstance::ApplyAsyncPhysicsCommand(FAsyncPhysicsTimestamp TimeStamp, const bool) Line 3399	C++
FBodyInstance::AddForceAtPosition(const UE::Math::TVector<double> & Force, const UE::Math::TVector<double> & Position, bool bAllowSubstepping, bool bIsLocalForce, const FAsyncPhysicsTimestamp TimeStamp, APlayerController * PlayerController) Line 3429	C++
UPrimitiveComponent::AddForceAtLocation(UE::Math::TVector<double> Force, UE::Math::TVector<double> Location, FName BoneName) Line 255	C++


UPrimitiveComponent
  FBodyInstance BodyInstance
    UBodySetup
	Chaos::FSingleParticlePhysicsProxy ActorHandle
	  IPhysicsProxyBase
	  Particle TPBDRigidParticle
	  FParticleHandle FGeometryParticleHandle
	  
UGeometryCollectionComponent
  FGeometryCollectionPhysicsProxy
    Chaos::FPBDRigidClusteredParticleHandle

FPBDRigidsSolver
  FPBDRigidsEvolutionGBF MEvolution
    FRigidClustering Clustering
	  FClusterUnionManager ClusterUnionManager
	    FClusterUnion ClusterUnions
		  FPBDRigidClusteredParticleHandle InternalCluster // The root cluster particle that we created internally to represent the cluster.
		    TPBDRigidClusteredParticleHandleImp
			  TPBDRigidParticleHandleImp
			    TKinematicGeometryParticleHandleImp
				  TGeometryParticleHandleImp
				    TParticleHandleBase
                      TPBDRigidClusteredParticles PBDRigidClusteredParticles
					    TPBDRigidParticles
						  TVector MP // MX counter part - new position? // MParticles.SetP(Index, MParticles.GetX(Index) + MParticles.GetV(Index) * Dt); // If we don't set P, UpdateParticlePosition in evolution may stomp over X with P().
						  TRotation MQ // MR counter part - new rotation?
						  TRigidParticles
						    TVec3 MI // Inertia
							Real MM // Mass
							TVector MAcceleration
							TVector MAngularAcceleration
							Real MLinearEtherDrag
							Real MAngularEtherDrag
						    TKinematicGeometryParticles
							  TKinematicGeometryParticlesImp
							    TVector MV // Velocity
								TVector MW // Angular velocity
							    TGeometryParticlesImp
								  FShapeInstanceArray MShapesArray
								  FConstraintHandleArray MParticleConstraints
								  TSimpleGeometryParticles
								    TRotation MR // Orientation in space
									FImplicitObjectPtr MGeometry // contains raw ptrs to every entry in both MSharedGeometry and MDynamicGeometry. It may also contain raw ptrs to geometry which is managed outside of Chaos.
								    TParticles
									  TVector MX // Position in space
									  TArrayCollection
						  

UClusterUnionComponent
  FClusterCreationParameters
  FAccelerationStructure << "Whether component level sweeps and overlaps against cluster unions should use an acceleration structure instead."
	Chaos::FImplicitObjectUnionClustered
	Chaos::FImplicitObjectUnion
  Chaos::FClusterUnionPhysicsProxy PhysicsProxy
    IPhysicsProxyBase
      Solver
      Owner
      Type(ClusterUnionProxy)
      SyncTimestamp
    Particle_External TPBDRigidParticle // Game thread particle
      // NO DIRTY FLAGS ALLOWED. We must strictly manage the dirty flags on the particle.
      // Setting the particle's XR on the particle will set the XR dirty flag but that isn't
      // used for the cluster union (there is no functionality in Chaos to let the particle
      // be easily managed by a proxy that isn't the single particle physics proxy). And if the
      // XR dirty flag is set, we'll try to access buffers that don't exist for cluster union proxies.
	    CHAOS_PROPERTY(ClusterXR, FParticlePositionRotation, EPhysicsProxyType::ClusterUnionProxy)
        CHAOS_PROPERTY(ClusterVelocities, FParticleVelocities, EPhysicsProxyType::ClusterUnionProxy)
	  
    Particle_Internal TPBDRigidClusteredParticleHandleImp == FClusterUnion::InternalCluster // Physics thread particle
    FClusterUnionIndex Chaos::FClusterUnionManager
      Chaos::FClusterUnion


Since:
1 FClusterUnionPhysicsProxy::PushToPhysicsState - pushes only XR and velocity

2 C:\Program Files\Epic Games\UE_5.4\Engine\Source\Runtime\Experimental\ChaosVehicles\ChaosVehiclesCore\Private\SimModule\DeferredForcesModular.cpp
Applies forces to internal particle

I dont think you can actully do AddForce on External particle and expect it to work


Internal is just an pointer. It is used during PushToPhysicsState - you actually need to know where what particle to modify!
Now proxy make sense - it contains both particle and handle and now how to move data in and out of physics. This does icludes some interpolation, looks like physics is allowed to laps!

Then what about thread safty?
There is ExecuteWrite wrapper that is used both when modifying external particle and internal handle. Looks like all of that is "owned" by physics thread - transform is what left to game thread.

ExecuteWrite on particle handle AddForce?
Actually geometry collection does it exactly? Well not really, instead of ExecuteWrite, it useses EnqueueCommandImmediate

Looks like I need to extend ClusterUnionComponent

Applying force to clusterunion particle handle did not work. Why?
Ok, it actually kind of works, but looks like if ship lies on the ground, it will not wake up

Connectivity graph  
How did I miss UClusterUnionReplicatedProxyComponent????
Huh, it gets added to actors by force!

Well if we just remove geometry collections from cluster union, and then create new one = we hit same 300 ms spike in UpdateAllClusterUnionProperties!
Shit.

But, it looks like that clust union can be connected to another cluster union.
Well there is then bCheckConnectivity flag
HandleConnectivityOnReleaseClusterParticle

What if cluster union is actuall supposed to work similar to constraint? I.e. each cluster union is a link?
2 unions 3 geom collections - does not work, only 2 got linked.
but union of unions? Sort of yes, and no. Crashes asserts etc.
		// AddReleased is the original behavior where if the particle to be added is a cluster, we will release the cluster first
		// and add its children instead.
		AddReleased, == may be cluster - is cluster union? Not geometry collection?

Maybe we can steal parts? Huh. Actuall you can! And it still spikes, but less ~180ms



That is what spiking:
1 call
TPBDRigidClustering<>::UnionClusterGroups
  FClusterUnionManager::FlushPendingOperations
    FClusterUnionManager::HandleDeferredClusterUnionUpdateProperties
      FClusterUnionManager::DeferredClusterUnionUpdate
        FClusterUnionManager::UpdateClusterUnionProperties
34 calls
      void GenerateConnectionGraph(FRigidClustering& Clustering, FClusterUnion& ClusterUnion)
        AddParticleToConnectionGraph
        GenerateConnectionGraph
			TPBDRigidClustering<>::GenerateConnectionGraph -- this is 
			... g<> :: UpdateConnectivityGraphUsingDelaunay TriangulationWithBoundsOverlaps
			
Question is: what for do you build ConnectionGraph? Hmm, it may be a graph for fracturing and not for union
What is that graph? 
Can you debug drawn it?
		// Connectivity Graph
		//    Build a connectivity graph for the cluster. If the EConnectionMethod::PointImplicit is specified
		//    and the ClusterIndex has collision particles then use the expensive connection
		//    method. Otherwise try the DelaunayTriangulation (subdivides convex hull into triangles)if not none.
		//
RemoveClusterUnionEdges -> that is specific to ClusterUnion - that is what we need to dig in!
		bool bChaosClusterUnionGenerateInterclusterEdges = true;
		FAutoConsoleVariableRef CVarChaosClusterUnionGenerateInterclusterEdges(
			TEXT("p.Chaos.ClusterUnion.GenerateInterclusterEdges"),
			bChaosClusterUnionGenerateInterclusterEdges,
			TEXT("Whether to generate intercluster edges automatically when adding to a cluster union (and remove them when removing from the cluster union).")
		);


To investigate:
    Huh, there is a api AddConnectivityEdgesBetween hmm
	
	enum class EClusterUnionOperation
	{
		Add,
		// AddReleased is the original behavior where if the particle to be added is a cluster, we will release the cluster first
		// and add its children instead.
		AddReleased,
		Remove,
		UpdateChildToParent -- what is that? <- UClusterUnionComponent::ForceSetChildToParent <- UClusterUnionComponent::AddComponentToCluster
	};
	
	    // We need to keep track of all the particles we touched here. We need this because UpdateClusterUnionParticlesChildToParent
		// is an *authoritative* update on the ChildToParent of the particle. However, UpdateAllClusterUnionProperties in certain cases
		// may try to recompute the ChildToParent using the position of the particle. To counteract this, we will force the ChildToParent
		// to be *temporarily* locked for the duration of the *next* UpdateAllClusterUnionProperties. However, unless bLock is true, we will restore the
		// lock state of the particle to what it was previously.
		
		
WICTORY! bChaosClusterUnionGenerateInterclusterEdges = false, reduces spike to unnoticable 16 ms!!!


Fields??
Create a cluster union and use a field to applay strain to it? Did not work. But regardless. Breaking geometry collection in the middle of the cluster do not fracture cluster itsefl.
